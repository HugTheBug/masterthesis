\chapter{УПРАВЛЕНИЕ ДВИЖЕНИЕМ ДЛЯ СЛОЖНОЙ ТРАССЫ}\label{chap3}

В данной главе формулируется математическая модель и задача оптимального управления для нахождения оптимальной управления при движении автомобиля по трассе. После формулировки приводится код решения задачи и результаты проведенных численных экспериментов. Также в данной главе приводится общая информаця о CARLA симуляторе, с помощью которого были проведены численные эксперименты.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Модель автомобиля}\label{2sec:yyy}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	Для проведения численных экспериментов используется модель автомобиля основанная на Tesla Model 3 Standard Range Plus \cite{wiki_tesla, official_tesla, dyno_tesla}. Важно заметить, что данный автомобиль имеет автоматическую коробку передач и потому компонентами управления являются только поворот руля и степени нажатия педалей газа и тормоза. Также этот автомобиль имеет электрический двигатель и только 3 передачи (нейтральную, обратную, переднюю), что существенно упрощает контроль скорости движения.

	Для управления автомобилем используется кинематическая модель велосипеда. Данная модель не учитывает силы трения/проскальзывания, инерции и сопротивления воздуха, важность которых возрастает с увеличением скорости движения. Однако выбранный диапазона скоростей (30-40 км/ч) достаточно низкий для того чтобы данная модель обеспечивала точность управления аналогичную намного более сложной динамической модели \cite{Olsson, Palmqvist}:
\includegraphics[width=\linewidth]{car_model.png}
	
$$
	\dot{x} = v \cos{ \psi },
$$
$$
	\dot{y} = v \sin{ \psi },
$$
$$
	\dot{ \psi } = \frac{ v }{ L } \tan{ \delta },
$$
$$
	0 \leq v \leq v^{max},
$$
$$
	-\delta^{max} \leq \delta \leq \delta^{max},
$$
	$ x $ --- положение машины на трассе по оси $ X $,
	$ y $ --- положение машины на трассе по оси $ Y $,
	$ v $ --- скорость движения,
	$ L $ --- длинна машины,
	$ \psi $ --- поворот оси машины относительно оси $ X $,
	$ \delta $ --- поворот колес машины относительно оси машины,

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Задача оптимального управления}\label{2sec:xxx} % xxx заменить на свою метку
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	Рассматривается задача о следовании автомобиля вдоль заранее проложенной кривой на дороге с поддержанием скорости близкой к заранее выбранной скорости.
	
	Кривая дороги представлена многочленом, построенным на основе точек пути, генерируемых с помощью отдельного класса методов, которые не рассматривается в этой работе. Целевая скорость для простоты предполагается постоянной на протяжении всего пути и равна 40 км/ч. 
	
	Решение задачи на каждом этапе состоит из получения информации о состоянии автомобиля, а также  траектории пути. Затем применяется MPC для вычисления угла поворота руля. После чего желаемая и текущая скорости передаются в PID для вычисления управления газом и тормозом. Такой подход к управлению, когда используются два отдельных метода для скорости движения автомобиля и положния на дороге, является довольно популярным, особенно для методов не использующих модель \cite{Dominguez, Polack}.
	
	MPC метод настроен на генерацию гладких траекторий с гладкими управлений и скоростью близкой к заданной. PID контроллер настроен на поддержание постоянных скоростей с минимальными колебаниями управлений.
	
		MPC для следования пути использует следующую модель:
$$
	\min{\sum_{t=0}^{N}( W_{ect}e_{ct_t}^2 + W_{e\psi}e_{\psi_t}^2 + \sum_{t=0}^{N-2} W_{\delta}(\delta_{t+1} - \delta_t)^2 },
$$
$$
	x_{t+1} = x_t + v \cos{ \psi_t } h, t = 0..N-1
$$
$$
	y_{t+1} = y_t + v \sin{ \psi_t } h, t = 0..N-1
$$
$$
	\psi_{t+1} = \psi_t + \frac{ v }{ L } \tan{ \delta_t } h, t = 0..N-1
$$
$$
	e_{ct_{t+1}} = y_{ref_t} - y_t + \psi_t \sin{ e_{\psi_t} } h, t = 0..N-1
$$
$$
	e_{\psi_{t+1}} = \psi_{ref_t} - \psi_t + \frac{ v }{ L } \tan{ \delta_t } h, t = 0..N-1
$$
$$
	-\delta^{max} \leq \delta_t \leq \delta^{max}, t = 0..N
$$
	
	$ e_{ct} $ --- отклонение машины от кривой траектории пути,
	$ y_{ref} $ --- координата $ y $ ближайшей точки траектории пути,
	$ e_\psi $ --- отклонение угла поворота машины от угла траектории пути,
	$ \psi_{ref} $ --- угол траектории пути в ближайшей точки кривой,
	$ dt $ --- временной шаг MPC
	$ N $ --- горизонт MPC
	$ W_v $, $ W_{etc} $, $ W_{e \psi} $, $ W_{\delta} $ --- веса целевой функции
	
	Важно заметить что в данной формулировке MPC управлением являются $ \delta $, а скорость $ v $ является средним арифметическим между текущей скоростью автомобиля и желаемой скоростью. Скорость предполагается постоянной на всем горизонте.
	
	Желаемая скорость движения $ v $ преобразуется с помощью следующей модели для PID:
	
$$
	u(t) = K_p e(t) + K_i \int_0^t e(t')dt' + K_d \frac{de(t)}{dt}
$$
$$
	e(t) = v_{ref}(t) - v_{cur}(t)
$$
$$
	\begin{cases}
	u(t) < -1, & u_t = 0, u_b = 1 \\
	-1 \leq u(t) \le 0, & u_t = 0, u_b = - u(t) \\
    0 \leq u(t) \leq 1, & u_t = u(t), u_b = 0 \\
    1 < u(t), & u_t = 1, u_b = 0
 	\end{cases}
$$
	$ u_t $ --- степень нажатия педали газа
	$ u_b $ --- степень нажатия педали тормоза
	
	После чего полученные $ u_t $, $ u_b $, $ \delta $ передаются в автомобиль.
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Реализация управления в Python}\label{2sec:xxx} % xxx заменить на свою метку
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	Здесь объяснена только реализации частей управления, отвечающих за следование желаемой траектории. Части урпавления отвечающие за определение координат автомобиля и прочих параметров движения, прокладывание пути на карте, вычисление желаемой траектории находятся за границами данной работы.
	
	Для начала рассмотрим схему реализации MPC. Мы начинаем с определения постоянных параметров MPC и  автомобиля:
\begin{lstlisting}
# длина горизонта MPC
N = 7
# длинна автомобиля
Lf = vehicle.bounding_box.extent.x
...
\end{lstlisting}
	После чего определяем начальные значения:
\begin{lstlisting}
# начальная координата по х
x_init = opti.parameter()
# начальная координата по y
y_init = opti.parameter()
...
\end{lstlisting}
	Затем создаем векторы компонентов состояния:
\begin{lstlisting}
# вектор коодинат по x
x = opti.variable(N) 
# вектор поворотов руля
delta = opti.variable(N - 1) 
...
\end{lstlisting}
	Устанавливаем начальные ограничения:
\begin{lstlisting}
# начальная координата по x
opti.subject_to(psi[0] == psi_init)
# начальное отклонение 
opti.subject_to(cte[0] == cte_init) 
...
\end{lstlisting}	
	Задаем динамику системы:
\begin{lstlisting}
# вычиляем i+1 координату по x
x_next = x[i] + v * cos(psi[i]) * dt 
# устанавливаем чему будет равна i+1 координата
opti.subject_to(x[i + 1] == x_next) 
...
\end{lstlisting}
	Создаем ограничения на управление:
\begin{lstlisting}
opti.subject_to(opti.bounded(-max_delta, delta, max_delta))
...
\end{lstlisting}
	Записываем целевую функцию:
\begin{lstlisting}
cost_func += weight_delta_change * ((delta[i + 1] - delta[i]) ** 2)
...
\end{lstlisting}
	И затем при каждом вызове MPC мы будет заполнять начальные значения на основе измерений:
\begin{lstlisting}
opti.set_value(x_init, transform.location.x)
opti.set_value(y_init, transform.location.y)
...
\end{lstlisting}
	И вычислять поворот руля:
\begin{lstlisting}
sol = opti.solve()
steer = value(delta)[0] / max_delta
\end{lstlisting}

	Теперь рассмотрим релизацию PID регулятора. Для начала определяем коэффициенты и размер вектора ошибок для интегральной части:
\begin{lstlisting}
# коэффициент пропорциональной части
K_P = 0.175 
# коэффициент дифференциальной части
K_D = 0.0065 
# коэффициент интегральной части
K_I = 0.5 
# временной шаг
dt = 0.04 
# вектор прошлых ошибок
e_buffer = deque(maxlen=30) 
\end{lstlisting}
	И затем при каждом вызове PID будет проводить следующие вычисления:
\begin{lstlisting}
# вычисляем ошибку
e = (target_speed - current_speed) 
# запоминаем её
e_buffer.append(e) 

if len(e_buffer) >= 2:
    # определяем производную ошибки
    de = (e_buffer[-1] - e_buffer[-2]) / dt 
    # определяем интеграл прошлых ошибок
    ie = sum(e_buffer) * dt 
else:
    de = 0.0
    ie = 0.0

# подсчет управления
u = np.clip(K_P * e + K_D * de + K_I * ie * dt), -1.0, 1.0)
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Результаты численных экспериментов}\label{2sec:xxx} % xxx заменить на свою метку
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	В проведенных численных экспериментах было рассмотрено движение автомобиля вдоль пути выделеного красным (со стартом внизу и финишем слева сверху):
\includegraphics[width=\linewidth]{city.png}
	
	В результате чего были получены следующие диаграммы:
	
\includegraphics[width=\linewidth]{diagram.png}
	
	И графики:
	
\includegraphics[width=\linewidth]{plot.png}

	При исследовании графика скорости важно понимать, что скорость автомобиля измерялась как изменение его координат на карте, а не через вращение колем и потому скорость на поворотах понижалась. График скорости показывает, что предложенный метод способен поддерживать скорость близкую к постоянной даже при резких поворотах. В связи с тем, что желаемая скорость оставлась постоянной на протяжении всего пути, управление автомобилем осуществлялось с помощью педали газа и без использования педали газа.
	
	В управлении газом присутствуют резкие скачки, что может быть объяснено реакцией PID контроллера на уменьшение скорости при движении по окружности во время поворотов.
	
	График поворота руля выглядит намного более гладким по сравнению с педалью газа, что следует из целевой функции MPC, которая нацелена на обеспечение гладкости траекторий движения.
	
	Отклонения от желаемой траектории невелики и возникают во время поворотов. Скачкообразность отклонений объясняется необходимостью вычислять желаемую траекторию заново перед каждым вызовом метода усправления, что приводит к тому что она постоянно смещается.
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{CARLA симулятор}\label{1sec:optimal-control}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	CARLA изначально разрабатывалась для поддержания разработки, обучения и валидации различных систем автоматического вождения. В дополнении к открытому исходному коду и протоколам, CARLA предоставляет открытые модели (участки городов, здания, автомобили), которые были специально созданы для этого и доступны для свободного использования. Платформа для симуляции поддерживает легко настраиваемые наборы сенсоров, погоду, полное управление статичными и динамическими актерами, создание карт и многое другое.
	Некоторые возможности:
	\begin{itemize}
		\item Серверная архитектура для множества клиентов: клиенты работающие на одной или нескольких машинах могут одновременно управлять различными актерами.
		\item Гибкое API: CARLA предоставляет мощное API, которое позволяет пользователям управлять всеми аспектами симуляции, в том числе созданием автомобильного движения на дороге, управлением пешеходами, погодой, сенсорами и многим другим
		\item Автономная система сенсоров для управления автомобилями: пользователи могут настраивать разнообразные сенсоры, такие как LIDAR, разнообразные камер, сенсор глубины, GPS и другие.
		\item Быстрая симуляция для планирования и управления: этот режим отключает отрисовку изображений чтобы предоставить быстрое исполнение симуляции автомобильного движения и поведения на дороге, для которого изображение не обязательно.
		\item Генерация карт: пользователя с легкостью могут создавать свои собственные карты соотвествующие OpenDrive стандарту с помощью таких программ как RoadRunner.
		\item Симуляция ситуаций на дороге: система ScenarioRunner позволяет пользователям создавать и исполнять разоичные дорожные ситуации основанные на различных поведениях.
		\item Интеграция с ROS: CARLA предоставляет интеграцию с ROS с помощью ROS-bridge
		\item Основы автоматического вождения: CARLA предоставляет основные обьекты для автоматического вождения, такие как AutoWare обьект.
	\end{itemize}
\bigskip

	Таким образом, определена математическая модель и формулировка задачи поиска оптимального управления движением автомобиля. Приведен метод решения описанной задачи, а также код реализации, написанный с использованием CasADi. Присутствуют результаты экспериментов подтверждающих работоспособность метода.