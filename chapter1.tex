\chapter{ОСНОВНЫЕ ПОНЯТИЯ И ОБЗОР ЛИТЕРАТУРЫ }\label{chap1}

В настоящей глава рассматриваются основные понятия, используемые в данной работе. Формулируются основные понятия, связанные с MPC методами. Приводится мотивация для использования MPC в решении задач оптимального управления. Особое внимание уделяется рассмотрению алгоритмов построения MPC-регуляторов и особенностям работы MPC для задач, связанных с беспилотными автомобилями. Изложены основные понятия, связанные с PID методами. Особое внимание уделяется влиянию отдельных составляющих PID регулятора. Приведена основаная теория для методов построения траекторий беспилотных автомобилей. Так же представлено краткое описание библиотеки CasADi, применяемой для реализации рассмотренных методов.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Мотивация использования MPC}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%	
	MPC - это метод управления, при котором компоненты управления получаются путем решения, в каждый момент времени, задачи оптимального управления с открытым циклом на конечном горизонте. Текущее состояние системы используется как начальное состояние для задачи, в процессе решения которой получается последовательность управлений, но только самое первое управления применяется к управляемой системе. 
	
	Важным преимуществом методов такого типа является их способность к решению задач в условиях сложных ограничений на управление и состояния. По этой причине они часто применяются в химической и связанных с ней отраслях промышленности \cite{svenska_19}, где удовлетворение ограничений является особенно важным, потому как наибольшая эффективность процессов достигается в состояниях, максимально близким к допустимым границам. 		
	
	Другой не менее важной особенностью MPC является возможность эффективно управлять системы с возмущениями, которые не могут быть учтены в моделях систем, что достигается благодаря вычислению нового управления на основе текущего состояния системы через равные промежутки времени. Примером таких систем являются беспилотные автомобили \cite{Jalali, Khajepour}.
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Основные понятия MPC}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	MPC по сути решает стандартные задачи оптимального управления (за исключением того что в MPC задача оптимального управления должна обладать конечным горизонтом в отличие от бесконечных горизонтов, применяемых в $H_2$ и $H_\infty$ линейных оптимальных управлениях). Основным отличием его от других методов является то, что MPC решает задачу оптимального управления в реальном времени для текущего состояния системы вместо того чтобы заранее определять управления для всех состояний системы. Решение в реальном времени получается с помощью нахождения управления в задаче оптимального управления с открытым циклом, где начальным состоянием является текущее состояние управляемой системы, что является задачей математического программирования. В то время как методы, заранее вычисляющие управления для всех состояний системы, обычно решают намного более сложные задачи динамического программирования, связанные с решением диффернциалов или дифференциальных уравнений Гамильтона-Якоби-Беллмана. С этой точко зрения MPC отличается от других методов только своей реализацией. Однако требование того, что задачи оптимального управления с открытым циклом должны решаться за подходящее время, требует использование конечного горизонта, что приводит к дополнительным сложностям.
	
	Общая формулировка MPC может быть представлен как:
$$
\min_{u} \sum_{i=1}^{H_p} J(z_i, u_i)
$$
$$
	z_0=z(0)			 измерения
$$
$$
z_{i+1}=f(z_i, u_i) модель системы
$$
$$
C(z_i, u_i) \leq M ограничения
$$
	где $J$ называется целевой функцией и может быть как линейной так и нелинейной. Зачастую $J$ является квадратичной функцией для того чтобы упростить решения задачи. Функция $C$ выражает ограничения на состояния системы и управления, а фукция $f$ представляет модель системы, обе эти функции могут быть как линейными так и нелинейными.
	
	Сумма в целевой функции рассчитывается до значения $H_p$, называемого горизонтом. Горизонт определяет количество будующих состояний системы и управлений, которые нужно учитывать на каждом шаге.
	
	MPC метод требует больших вычилительных затрат так как задача оптимального управления должна решаться через регулярные, зачастую малые, промежутки времени. Поэтому для упрощения вычислений ограничения и модель системы зачастую выбираются линейными с квадратичной целевой функцией. Линейная задача MPC может быть представлена как:

$$
	\min_u{ z^T_{H_p} Pz_{H_p} + \sum_{i=1}^{H_p-1}z_i^T Qz_i + u_i^T Ru_i },
$$
$$
	z_0=z(0)			 измерения
$$
$$
	z_{i+1}=Az_i + Bu_i линейная модель системы
$$
$$
	Cz_i + Du_i \leq b  ограничения
$$  
$$
	R \geq 0, Q \geq 0  веса целевой функции
$$ 
	где $u_i=(u_0, u_1, ... , u_{H_p - 1})$ это последовательность оптимальных управлений, которые минимизируют целевую функцию и $z$ это состояние системы, которую мы пытаемся управлять.
	
	Четыре основные части MPC это целевая функция, модель системы, ограничения и измерения состояния. Целевая функция имеет три параметра или матрицы весов $Q$, $R$ и $P$. Эти матрицы используются для того чтобы повлиять на состояния и управления во время оптимизации и подбор этих параметров крайне важен для производительности MPC. Матрица $Q$ обычно является диагональной мтарицей размера $n \times n$ и матрица R имеет размер $m \times m$ где $n$ является числом состояний и $m$ числом компонент управления.
	
	Матрицы $C$ и $D$ используются для выбора состояний и управлений, которые ограничены с помощью $b$. Обычно $D$ используется для того чтобы наложить ограничения на сигналы управления $u$ в виде $u \in [u_{min}, u_{max}]$. Матрица $P$ которая находится возле последнего предсказанного состояния или терминального состояния $z_{H_p}$ называется терминальной стоимостью. Терминальная стоимость предназначена для того чтобы повысить важность финального состояния для достижения оптимального состояния. Обычно это достигается выбором элементов $P$ таким образом что они больше чем элементы матрицы $Q$.
	
	MPC проблема сформулированная ранее является линейным и используется для того чтобы привести систему к нулю, также эта задача может изменена чтобы приводить систему к ненулевому значению.  В такой ситуации вместо минимизации состояния $z$ и управления $u$ происходит минимизация ошибок между ними и целевыми значениями. Для этого добавялется новые состояния $\widetilde{z}=z - z_{ref}$ и $\widetilde{u}=u - u_{ref}$. После чего система выглядит так:

$$
	\min_u{ \widetilde{z}^T_{H_p} P\widetilde{z}_{H_p} + \sum_{i=0}^{H_p-1}\widetilde{z}_i^T Q\widetilde{z}_i + \widetilde{u}_i^T R\widetilde{u}_i},
$$
$$
	z_0=z(0)			
$$
$$
	\widetilde{z}_i = (z_i - z_{ref})
$$
$$
	\widetilde{u}_i = (u_i - u_{ref})
$$
$$
	\widetilde{z}_{i+1}=A\widetilde{z}_i + B\widetilde{z}_i
$$
$$
	C\widetilde{z}_i + D\widetilde{u}_i \leq b 
$$  
	Оптимальное управление в такой системе рассчитывается как $u^* = \widetilde{u}^* + u_{ref}$.
	
	В данной работе рассматривается проблема следования пути и потому значение, к которому приводит система, будет изменяется в зависимости от времени. Это значит что целевые значения $z_{ref}$ и $u_{ref}$ изменятся на $u_{ref} = (u_{ref_1}, ..., u_{ref_{H_p}})$ и $z_{ref} = (z_{ref_1}, ..., z_{ref_{H_p}})$. 
	
	Таким образом формулировка MPC изменяется на:
$$
	\min_u{ \widetilde{z}^(T)_{H_p} P\widetilde{z}_{H_p} + \sum_{i=0}^{H_p-1}\widetilde{z}_i^T Q\widetilde{z}_i + \widetilde{u}_i^T R\widetilde{u}_i },
$$
$$
	z_0=z(0)			
$$
$$
	\widetilde{z}_i = (z_i - z_{ref_i}), i = 0...H_p-1
$$
$$
	\widetilde{u}_i = (u_i - u_{ref_i}), i = 0...H_p-1
$$
$$
	\widetilde{z}_{i+1}=A\widetilde{z}_i + B\widetilde{z}_i, i = 0...H_p-1
$$
$$
	C\widetilde{z}_i + D\widetilde{u}_i \leq b , i = 0...H_p-1
$$ 
	Важно заметить, что для решения такой задачи потребуется определить целевые значения для всех состояний и управлений.
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Алгоритм построения MPC-регулятора}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	В случае MPC, который решает математическую проблемой оптимизации, подбор параметров в основном связан с целевой функцией и ограничениями на управления и состояния. 
	В целевой функции присутствует три матрицы весов $Q$, $R$ и $P$. Матрица $Q$ используется в комбинации с состоянием системы в целевой функции для создания квадратичной стоимости $z^T Q z$. На практике $Q$ уменьшает любые отклонения в состояниях. Выбор одинаковых весов для всех состояний позволит поддерживать их одинаково далеко от целевых состояний. В случае если некоторые состояния более важны чем другие, веса должны быть выбраны соответствующим образом. Также веса должны быть выбраны с учетом единиц измерения состояний, например использование одинаковых весов для радиан и метров приведет к тому, что отклонение в один метр будет влиять на целевую функцию так же сильно, как и отклонение в один радиан.
	В задачах следования пути автомобилем координаты $x$, $y$ обычно считаются наиболее важными так как машина всегда должна оставаться на дороге. Ориентация машины не является настолько важной так как из-за проскальзываний шин результирующее направление движения автомобиля может не совпадать с его физической ориентацией.
	
	Матрица $R$ находится возле управления $u$ и используется как матрица весов для компонент управления. По аналогии с матрицей $Q$ веса матрицы $R$ выбираются в соотвествии размерностью и важностью отдельных компонент. 
	
	Матрица терминальной стоимости $P$ крайне важна для MPC, несмотря на то что она влияет только на финальное состояние $z_{H_p}$. Так как MPC предсказывает состояния на горизонте, итерации между начальным состоянием $z_0$ и финальным состоянием $z_{H_p}$ могут представлены как шаги от начальной точки до цели. В обычном MPC, эта матрица влияет не на то как именно MPC достигает цели, но на то что цель достигается. Обычно элементы $P$ выбираются большими чем элементы $Q$ чтобы показать, что финальное состояние важнее пути к нему. В MPC для следования пути, путь и цель одинаково важны и матрица $P$ используется для стабилизации управления.
	
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Основные понятия PID}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	PID регулятор вяляется одним из методов управления с обратной связью. В отсуствие информации о внутренних процессах системы PID исторически считается один из наиболее эффективных методов и сейчас является одним из наиболее популяных в промышленности \cite{Visioli}. Этот метод также может быть легко настроен под конкретную систему. Важно заметить, что PID не гарантирует оптимальность управления системой или устойчивость системы.
	
	Общий алгоритм PID может быть записан так:
$$
	u(t) = K_p e(t) + K_i \int_0^t e(t')dt' + K_d \frac{de(t)}{dt}
$$
$$
e(t) = y(t) - y_{ref}(t)
$$
	где $y$ является измерением системы, $y_{ref}$ --- желаемым значением, $u$ --- управлением системой, $e$ --- ошибкой. PID метод рассчитывает ошибку между измерениями состояния системы и желаемыми значениями, после чего он старается минимизировать ошибку влияя на управляемую переменную. Таким образом получаемое управление состоит из трех составляющих: пропорциональная P (зависит от текущей ошибки), интегральная I (пропорциональна прошлым ошибкам), дифференциальная D (пропорциональна предполагаемым будующим ошибкам).
	
	При управлении некоторыми системами лучших результатов можно добиться использованием только двух или одной частей PID и таким образом он првращается в PI, PD, P или I регулятор. PI регуляторы довольно популярны так как дифференциальная составляющая управления сильно подвержена влиянию ошибок измерений, в то время как отсутствие интегральной составляющей может привести к тому что система никогда не достигнет её целевого состояния.
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Влияние отдельных составяющих регулятора}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	Пропорциональная составляющая реагирует на размер текущей ошибки: большое значение ошибки означает сильную реакцию управления. Ошибки будут уменьшаться при увеличении пропорционального коэффициента $K_p$, однако система будет более подвержена колебаниям. Также данная составляющая перестает работать для очень малых ошибок. Другим недостатком этой составляющей является то, что она не реагирует на скорость изменения ошибок. На практике коэффициент данной составляющей выбирается так чтобы она оказывала наибольшее влияние на управление среди всех составляющих PID.
	
	Интегральная составляющая предназначена для корректирования малых ошибок. Эта составляющая учитывает ошибки в течение периода времени и увеличивает важность малых ошибок с течением времени. Интегральная составляющая равна ошибкам умноженным на время их присутствия. Таким образом интегральная составляющая увеличивает реакцию PID на ошибку с течением пока времени она не будет скорректирована. Временной промежуток интеграла также может быть настроен для конкретной системы. Например более короткий временной промежуток приводит к более быстрому исправлению ошибок. Однако слишком короткий промежуток приведет к неустойчивой работе регулятора, а слишком длинный приведет к тому что возникающие ошибки будут слишком долго влиять на управление системой.
	
	Дифференциальная составляющая ориентируется на скорость изменения ошибок. Она регирует на резкие изменения системы и пытается предсказать будующее поведение системы, что улучшает время стабилизации системы и её устойчивость. Крайне важно чтобы дифференциальная часть не была слишком большой, иначе она вызовет слишком сильные колебания управление или неустойчивую работу регулятора. На практике дифференциальная часть используется редко из-за сильно влияния шума во время измерений на неё.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Решение задач с использованием CasADi для Python}\label{1sec:optimal-control}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	CasADI это кроссплатформенная библиотека с открытым исходным кодом обладающая API для Python, C++, Matlab/Octave и предназначенная для нелинейной оптимизации и алгоритмического дифференцирования \cite{Andersson}. Она использует быструю и эффективную реализацию различных методов для численного оптимального управления.

	Основа CasADi это символический фреймворк реализующий прямой и обратный метод алгоритмического дифференцирования на графах выражений для построения градиентов, больших и разреженных якобианов и гессианов. Эти графы выражений представленные в виде функциональных обьектов, могут быть вычислены с помощью виртуальной машины или экспортированы в C код.

	Пример использования:
\begin{lstlisting}
from casadi import *

# Создаем символический скаляр/матрицу
x = MX.sym('x',5)

# Создаем выражение
y = norm_2(x)

# Градиент выражения -> новое выражение
grad_y = gradient(y,x)

# Создаем функцию для вычисления выражения
f = Function('f',[x],[grad_y])

# Вычисляем алгебраически
grad_y_num = f([1,2,3,4,5])
\end{lstlisting}

	CasADi так же способна решать задачи для динамических систем. Задачи с начальным значением в обыкновенной или дифференциально-алгебраических уравнениях (ОДУ/ДАУ) могут быть вычислены используя явный или неявный метод Рунге-Кутта или интерфейсы к другим методам из SUNDIALS набора. Производные вычисляются использую чувствительные выражения до произвольного порядка.

	Класс проблем:
$$
	\dot{x} = f_{ode}(t;x;z;p), x(0) = x_0
$$
$$
	0 = f_{alg}(t;x;z;p)
$$

	Пример задачи:
$$
	\dot{x_1} = (1-x_2^2)x_1 - x_2
$$
$$
	\dot{x_2} = x_1,
$$
$$
	x_1(0) = 0,
$$
$$
	x_2(0) = 1.
$$

	Пример использования:
\begin{lstlisting}
import casadi.*

x = MX.sym('x',2) # Два состояния

# Выражение для ОДУ правой части
z = 1-x[1]**2
rhs = vertcat(z*x[0]-x[1],x[0])

ode = {}           # определение ОДУ
ode['x'] = x       # состояния
ode['ode'] = rhs   # правая часть

# Конструируем функцию которая интегрирует через каждые 4 с
F = integrator('F','cvodes',ode,{'tf':4})

# Начинаем с x=[0;1]
res = F(x0=[0,1])

print(res["xf"])
\end{lstlisting}

	CasADi предоставляет различные методы для решения нелинейных задач и задач квадратичного программирования, в том числе и с целочисленными переменными.

	Класс задач:
$$
	\min_x f(x;p),
$$
$$
	x_{lb} \leq x \leq x_{ub},
$$
$$
	g_{lb} \leq g(x;p) \leq g_{ub}.
$$

	Пример задачи:
$$
	\min_{x,y,z} x^2+100z^2,
$$
$$
	z+(1-x)^2-y=0.
$$

	Пример использования:
\begin{lstlisting}
from casadi import *

# Символические выражения
x = MX.sym('x')
y = MX.sym('y')
z = MX.sym('z')
f = x**2+100*z**2
g = z+(1-x)**2-y

nlp = {}                   # Описание задачи
nlp['x']= vertcat(x,y,z)   # Переменные
nlp['f'] = f               # Целевая функция
nlp['g'] = g               # Ограничения

# Создаем обьект решающий задачу
F = nlpsol('F','ipopt',nlp)

# Решаем задачу используя предположение
F(x0=[2.5,3.0,0.75],ubg=0,lbg=0)
\end{lstlisting}		

	CasADi предоставляет обширный набор дифференциальных операций для матричных графов выражений, включая распространенные матричнозначные операции, серилизованные или параллельные вызовы функций, неявные функции, интеграторы, таблицы построенные на сплайнах и внешний код.

	Эти строительные блоки позволяют пользователю запрограммировать огромное множество задач оптимального управления.

	Пример использования, являющийся комбинацией описанных выше примеров:
\begin{lstlisting}
from casadi import *

x = MX.sym('x',2) # Два состояния
p = MX.sym('p')   # Свободный параметр

# Выражение для ОДУ правой части
z = 1-x[1]**2
rhs = vertcat(z*x[0]-x[1]+2*tanh(p),x[0])

# ОДУ объявление со свободным параметром
ode = {'x':x,'p':p,'ode':rhs}

# Конструируем функцию которая интегрирует через 1 с
F = integrator('F','cvodes',ode,{'tf':1})

# Вектор управления
u = MX.sym('u',4,1)

x = [0,1] # Начальное состояние
for k in range(4):
  # Интегрируем на 1с во времени
  # вызываем символический интегратор
  res = F(x0=x,p=u[k])
  x = res["xf"]

# Объявление задачи
nlp = {'x':u,'f':dot(u,u),'g':x}

# Решаем используя IPOPT
solver = nlpsol('solver','ipopt',nlp)
res = solver(x0=0.2,lbg=0,ubg=0)

plot(res["x"])
\end{lstlisting}
\bigskip

Каждая глава завершается краткими выводами. Разумный способ написания выводов --- переписать (это значит использовать те же мысли, но не копировать фразы!) в утвердительной форме (рассмотрено, получено и т.д.) то, что написано во врезке. 