\chapter{ОСНОВНЫЕ ПОНЯТИЯ И ОБЗОР ЛИТЕРАТУРЫ }\label{chap1}

В настоящей главе рассматриваются основные понятия, используемые в данной работе. Формулируются основные понятия, связанные с MPC методами. Приводится мотивация для использования MPC в решении задач оптимального управления. Особое внимание уделяется рассмотрению алгоритмов построения MPC-регуляторов и особенностям работы MPC для задач, связанных с беспилотными автомобилями. Изложены основные понятия, связанные с PID методами. Особое внимание уделяется влиянию отдельных составляющих PID регулятора и настройке параметров. Приведена основная теория для методов построения траекторий беспилотных автомобилей с использованием системы координат Френе. Так же представлено краткое описание библиотеки CasADi, применяемой для реализации рассмотренных методов.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Мотивация использования MPC}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%	
	MPC - это метод управления, при котором компоненты управления получаются путем решения, в каждый момент времени, задачи оптимального управления с открытым циклом на конечном горизонте. Текущее состояние системы используется как начальное состояние для задачи, в процессе решения которой получается последовательность управлений, но только самое первое управления применяется к управляемой системе. 
	
	Важным преимуществом методов такого типа является их способность к решению задач в условиях сложных ограничений на управление и состояния. По этой причине они часто применяются в химической и связанных с ней отраслях промышленности \cite{svenska_19}, где удовлетворение ограничений является особенно важным, потому как наибольшая эффективность процессов достигается в состояниях, максимально близким к допустимым границам. 		
	
	Другой не менее важной особенностью MPC является возможность эффективно управлять системы с возмущениями, которые не могут быть учтены в моделях систем, что достигается благодаря вычислению нового управления на основе текущего состояния системы через равные промежутки времени. Примерами таких систем являются беспилотные автомобили \cite{Jalali, Khajepour}.
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Основные понятия MPC}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	MPC по сути решает стандартные задачи оптимального управления (за исключением того что в MPC задача оптимального управления должна обладать конечным горизонтом в отличие от бесконечных горизонтов, применяемых в $H_2$ и $H_\infty$ линейных оптимальных управлениях). Основным отличием его от других методов является то, что MPC решает задачу оптимального управления в реальном времени для текущего состояния системы вместо того, чтобы заранее определять управления для всех состояний системы. Решение в реальном времени получается с помощью нахождения управления в задаче оптимального управления с открытым циклом, где начальным состоянием является текущее состояние управляемой системы, что является задачей математического программирования. В то время как методы, заранее вычисляющие управления для всех состояний системы, обычно решают намного более сложные задачи динамического программирования, связанные с решением дифференциалов или дифференциальных уравнений Гамильтона-Якоби-Беллмана. С этой точки зрения MPC отличается от других методов только своей реализацией. Однако требование того, что задачи оптимального управления с открытым циклом должны решаться за подходящее время, требует использование конечного горизонта, что приводит к дополнительным сложностям.
	
	Общая формулировка MPC может быть представлена как:
$$
\min_{u} \sum_{i=1}^{H_p} J(z_i, u_i)
$$
$$
	z_0=z(0)			 измерения
$$
$$
z_{i+1}=f(z_i, u_i) модель системы
$$
$$
C(z_i, u_i) \leq M ограничения
$$
	где $J$ называется целевой функцией и может быть как линейной так и нелинейной. Зачастую $J$ является квадратичной функцией для того чтобы упростить решения задачи. Функция $C$ выражает ограничения на состояния системы и управления, а функция $f$ представляет модель системы, обе эти функции могут быть как линейными, так и нелинейными.
	
	Сумма в целевой функции рассчитывается до значения $H_p$, называемого горизонтом. Горизонт определяет количество будущих состояний системы и управлений, которые нужно учитывать на каждом шаге.
	
	MPC метод требует больших вычислительных затрат так как задача оптимального управления должна решаться через регулярные, зачастую малые, промежутки времени. Поэтому для упрощения вычислений ограничения и модель системы зачастую выбираются линейными с квадратичной целевой функцией. Линейная задача MPC может быть представлена как:

$$
	\min_u{ z^T_{H_p} Pz_{H_p} + \sum_{i=1}^{H_p-1}z_i^T Qz_i + u_i^T Ru_i },
$$
$$
	z_0=z(0)			 измерения
$$
$$
	z_{i+1}=Az_i + Bu_i линейная модель системы
$$
$$
	Cz_i + Du_i \leq b  ограничения
$$  
$$
	R \geq 0, Q \geq 0  веса целевой функции
$$ 
	где $u_i=(u_0, u_1, ... , u_{H_p - 1})$ это последовательность оптимальных управлений, которые минимизируют целевую функцию и $z$ это состояние системы, которую мы пытаемся управлять.
	
	Четыре основные части MPC это целевая функция, модель системы, ограничения и измерения состояния. Целевая функция имеет три параметра или матрицы весов $Q$, $R$ и $P$. Эти матрицы используются для того, чтобы повлиять на состояния и управления во время оптимизации и подбор этих параметров крайне важен для производительности MPC. Матрица $Q$ обычно является диагональной матрицей размера $n \times n$ и матрица R имеет размер $m \times m$ где $n$ является числом состояний и $m$ числом компонент управления.
	
	Матрицы $C$ и $D$ используются для выбора состояний и управлений, которые ограничены с помощью $b$. Обычно $D$ используется для того чтобы наложить ограничения на сигналы управления $u$ в виде $u \in [u_{min}, u_{max}]$. Матрица $P$ которая находится возле последнего предсказанного состояния или терминального состояния $z_{H_p}$ называется терминальной стоимостью. Терминальная стоимость предназначена для того, чтобы повысить важность финального состояния для достижения оптимального состояния. Обычно это достигается выбором элементов $P$ таким образом что они больше чем элементы матрицы $Q$.
	
	MPC проблема сформулированная ранее является линейным и используется для того чтобы привести систему к нулю, также эта задача может изменена чтобы приводить систему к ненулевому значению.  В такой ситуации вместо минимизации состояния $z$ и управления $u$ происходит минимизация ошибок между ними и целевыми значениями. Для этого добавялется новые состояния $\widetilde{z}=z - z_{ref}$ и $\widetilde{u}=u - u_{ref}$. После чего система выглядит так:

$$
	\min_u{ \widetilde{z}^T_{H_p} P\widetilde{z}_{H_p} + \sum_{i=0}^{H_p-1}\widetilde{z}_i^T Q\widetilde{z}_i + \widetilde{u}_i^T R\widetilde{u}_i},
$$
$$
	z_0=z(0)			
$$
$$
	\widetilde{z}_i = (z_i - z_{ref})
$$
$$
	\widetilde{u}_i = (u_i - u_{ref})
$$
$$
	\widetilde{z}_{i+1}=A\widetilde{z}_i + B\widetilde{z}_i
$$
$$
	C\widetilde{z}_i + D\widetilde{u}_i \leq b 
$$  
	Оптимальное управление в такой системе рассчитывается как $u^* = \widetilde{u}^* + u_{ref}$.
	
	В данной работе рассматривается проблема следования пути и потому значение, к которому приводит система, будет изменяется в зависимости от времени. Это значит что целевые значения $z_{ref}$ и $u_{ref}$ изменятся на $u_{ref} = (u_{ref_1}, ..., u_{ref_{H_p}})$ и $z_{ref} = (z_{ref_1}, ..., z_{ref_{H_p}})$. 
	
	Таким образом формулировка MPC изменяется на:
$$
	\min_u{ \widetilde{z}^T_{H_p} P\widetilde{z}_{H_p} + \sum_{i=0}^{H_p-1}\widetilde{z}_i^T Q\widetilde{z}_i + \widetilde{u}_i^T R\widetilde{u}_i },
$$
$$
	z_0=z(0)			
$$
$$
	\widetilde{z}_i = (z_i - z_{ref_i}), i = 0...H_p-1
$$
$$
	\widetilde{u}_i = (u_i - u_{ref_i}), i = 0...H_p-1
$$
$$
	\widetilde{z}_{i+1}=A\widetilde{z}_i + B\widetilde{z}_i, i = 0...H_p-1
$$
$$
	C\widetilde{z}_i + D\widetilde{u}_i \leq b , i = 0...H_p-1
$$ 
	Важно заметить, что для решения такой задачи потребуется определить целевые значения для всех состояний и управлений.
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Алгоритм построения MPC-регулятора}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	В случае MPC, который решает математическую проблемой оптимизации, подбор параметров в основном связан с целевой функцией и ограничениями на управления и состояния. 
	
	В целевой функции присутствует три матрицы весов $Q$, $R$ и $P$. Матрица $Q$ используется в комбинации с состоянием системы в целевой функции для создания квадратичной стоимости $z^T Q z$. На практике $Q$ уменьшает любые отклонения в состояниях. Выбор одинаковых весов для всех состояний позволит поддерживать их одинаково далеко от целевых состояний. В случае если некоторые состояния более важны чем другие, веса должны быть выбраны соответствующим образом. Также веса должны быть выбраны с учетом единиц измерения состояний, например использование одинаковых весов для радиан и метров приведет к тому, что отклонение в один метр будет влиять на целевую функцию так же сильно, как и отклонение в один радиан.
	
	В задачах следования пути автомобилем координаты $x$, $y$ обычно считаются наиболее важными так как машина всегда должна оставаться на дороге. Ориентация машины не является настолько важной так как из-за проскальзывания шин результирующее направление движения автомобиля может не совпадать с его физической ориентацией.
	
	Матрица $R$ находится возле управления $u$ и используется как матрица весов для компонент управления. По аналогии с матрицей $Q$ веса матрицы $R$ выбираются в соответствии с размерностью и важностью отдельных компонент. 
	
	Матрица терминальной стоимости $P$ крайне важна для MPC, несмотря на то что она влияет только на финальное состояние $z_{H_p}$. Так как MPC предсказывает состояния на горизонте, итерации между начальным состоянием $z_0$ и финальным состоянием $z_{H_p}$ могут представлены как шаги от начальной точки до цели. В обычном MPC, эта матрица влияет не на то, как именно MPC достигает цели, но на то, что цель достигается. Обычно элементы $P$ выбираются большими чем элементы $Q$ чтобы показать, что финальное состояние важнее пути к нему. В MPC для следования пути, путь и цель одинаково важны, и матрица $P$ используется для стабилизации управления.
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Нелинейный MPC-регулятор}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	Многие системы по своей натуре нелинейны, и применение линейных моделей для них не сможет описать их динамику достаточно точно. MPC-регуляторы работающие с нелинейными моделями систем называются нелинейными MPC-регуляторами. 
	
	Математически задача для NMPC с постоянным временем может быть сформулирована следующим образом. Для нелинейного дифференциального уравнения:
	
$$
\dot{x}(t)=f(x(t),u(t)),
$$
$$
x(0)=x_0
$$
	с ограничениями на состояние и управление:
$$
u(t) \in U, \forall t \geq 0,
$$
$$
x(t) \in X, \forall t \geq 0.
$$
	где вектора $x(t) \in R^n$ и $u(t) \in R^m$ являются вектором состояния и вектором управления. Предполагается что $U$ - компакт, а множество $X$ связанно.
	Зачастую они представляют собой прямоугольники:
$$
U = \{ u \in R^m | u_{min} \leq u \leq u_{max} \},
$$
$$
X = \{ x \in R^n | x_{min} \leq x \leq x_{max} \},
$$
	С векторами ограничений $u_{min}, u_{max}, x_{min}, x_{max}$.
	И NMPC будет решать следующую задачу оптимального управления с конечным горизонтом:

$$
\min_{\overline{u}(\cdot)} J(x(t),\overline{u}(\cdot)),
$$
	с ограничениями:
$$
\dot{\overline{x}}(\tau)=f(\overline{x}(\tau),\overline{u}(\tau)), \overline{x}(t)=x(t),
$$
$$
\overline{u}(\tau) \in U, \forall \tau \in [t,t+T_c],
$$
$$
\overline{u}(\tau)=\overline{u}(t+T_c), \forall \tau \in [t+T_c, t+T_p],
$$
$$
\overline{x}(\tau) \in X, \forall \in [t,t+T_p]
$$
	с целевой функцией:
$$
J(x(t),\overline{u}(\cdot))=\int_t^{t+T_p}F(\overline{x}(\tau),\overline{u}(\tau))d \tau
$$

 	Где $T_p$ - горизонт предсказания, $T_c$ - горизонт управления и $T_c < T_p$. $\overline{x}(\cdot)$ - это траектория системы управляемой функцией $\overline{u}(\cdot) : [t,t+T_p] \rightarrow U$ при начальном значении $x(t)$. Причем внутренние переменные регуляторы обозначены с помощью черты сверху. Различие между реальными переменными системы и переменными внутри регулятора необходимо из-за различия между предсказанными состояниями системы и полученными измерениями (что возникает из-за сдвига горизонта времени на каждом шаге метода).
 	
 	Функция стоимости $J$ определена с использованием функции стоимости этапа, которая зачастую представляется в квадратичной форме:
$$
F(x,u)=(x-x_s)^TQ(x-x_s)+(u-u_s)^TR(u-u_s)
$$
	Где $x_s$, $u_s$ обозначают желаемую траекторию и могут зависеть от времени. А положительно определенные матрицы $Q$, $R$ являются матрицами весов.
	
	Оптимальным решением для такой системы является $\overline{u}*(\cdot,x(t)):[t,t+T_p]\rightarrow U$. Решение находится в моменты времени $t_j=j\delta,j=0,1,...$ и управление применяемое к системе определяется последовательностью оптимальных решений 
$$
u(t)=\overline{u}*(t;x(t_j)) 
$$
	где $t_j$ является ближайшим моментом времени к $t$ при условии $t_j \leq t$. Таким образом, система с обратной связью определена как:
$$
\dot{x}(t)=f(x(t),\overline{u}*(t;x(t_j))).
$$
	А оптимальная стоимость для задачи в зависимости от состояния определена как функция $V$:
$$
V(x)=J(x,\overline{u}*(\cdot,x)).
$$
	Функция $V$ важна при исследовании устойчивости NMPC, так как она зачастую является кандидатом для функции Ляпунова.
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Вычисление решений с помощью NMPC}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	NMPC требует многократного решения нелинейной задачи оптимального управления. В случае линейного MPC решение задачи может быть найдено как квадратичной задачи, которое может быть найдено за короткое время, что и требуется для эффективной работы MPC подхода. Но для работы NMPC требуется поиск решения нелинейной задачи, что требует больших вычислительных затрат и делает NMPC подходы неприменимыми в условиях жестко ограниченных технических ресурсов. Для решения этой проблемы существует множество методов, использующих особенности структуры задачи для упрощения её решения.
	
	Для решения задач NMPC часто применяются прямые методы оптимизации, основанные на конечномерной параметризации управления и состояния системы. Основная идея прямых методов заключается в превращении бесконечномерной задачи в конечномерную нелинейную задачу. Эта идея реализуется конечномерной параметризацией управления и иногда состояния системы и нахождением или аппроксимацией решения полученного дифференциального уравнения. Параметризация управления может быть осуществлена любым способом и обычно осуществляется как:
	
$$
\overline{u}(\tau,q), \tau \in [t,t+t_p],
$$
	где $q$ - вектор параметров. Значения $\overline{u}(\tau,q)$ могу быть определены к примеру помощью ряда Фурье, но часто выбираются как кусочно-постоянная функция.
	
	Очевидно, что хотя пространство параметров конечномерно, наличие ограничений на состояние и управление приводит к полу-бесконечной задаче оптимизации. Обычно эта проблема решается через параметризацию ограничений управления с помощью ранее выбранных параметров. При этом ограничения на состояние или учитываются как еще одно слагаемое в целевой функции или проверяются только для конечно множества моментов времени из горизонта предсказания. В результате применения параметризации управления полученная конечномерная задача оптимизации выглядит так (без учета ограничений, преобразованных по ранее описанной схеме):
$$
\min_q J(\overline{u}(\cdot,q),x(t),t,t+T_p),
$$

	Существуют три основных подхода для эффективного решения полученных параметризованных задач.

	Первым подходом к решению полученной задачи является последовательный подход. Он заключатся в параметризации управления $\overline{u}(\tau,q)$ после чего происходит интегрирование дифференциального уравнения и стоимости. В результате параметры управления определяют степени свободы системы. Для каждого вычисления стоимости $J(\{\overline{u}_1, ..., \overline{u}_N,x(t),t,t+T_p\})$ при решении задачи дифференциальное уравнение и целевая функция интегрируются с использованием текущих значений параметров оптимизации.
	
	Другим подходом является одновременный подход. Он заключается в нахождении решения дифференциального уравнения и задачи оптимизации одновременно. Для этого дифференциальные уравнения приводятся в дискретную форму и добавляются в задачу оптимизации как дополнительные ограничения. Обычно одновременные подходы используют метод коллокации для дискретизации дифференциальных уравнений. В результате получаются очень большие и очень разреженные нелинейные проблемы, что может использовано для эффективного нахождения решения.
	
	Третьим подходом является прямая множественная стрельба, где горизонт оптимизации разделяется на несколько интервалов со своей собственной локальной параметризацией для управления. Дифференциальные уравнения и целевые функции на этих интервалах интегрируются независимо от друг друга. Непрерывность получаемой в результате траектории достигается с помощью введения дополнительных ограничений для задачи. Полученная задачи опять таки будет иметь разреженную структуру, которая используется для эффективного поиска решения.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Основные понятия PID}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	PID регулятор является одним из методов управления с обратной связью. При отсутствии информации о внутренних процессах системы PID исторически считается один из наиболее эффективных методов и сейчас является одним из наиболее популярных в промышленности \cite{Visioli}. Этот метод также может быть легко настроен под конкретную систему. Важно заметить, что PID не гарантирует оптимальность управления системой или устойчивость системы.
	
	Общий алгоритм PID может быть записан так (параллельная форма записи):
$$
	u(t) = K_p e(t) + K_i \int_0^t e(t')dt' + K_d \frac{de(t)}{dt}
$$
$$
e(t) = y(t) - y_{ref}(t)
$$
	где $y$ является измерением системы, $y_{ref}$ --- желаемым значением, $u$ --- управлением системой, $e$ --- ошибкой. PID метод рассчитывает ошибку между измерениями состояния системы и желаемыми значениями, после чего он старается минимизировать ошибку влияя на управляемую переменную. Таким образом получаемое управление состоит из трех составляющих: пропорциональная P (зависит от текущей ошибки), интегральная I (пропорциональна прошлым ошибкам), дифференциальная D (пропорциональна предполагаемым будущим ошибкам).
	
	Стандартная форма записи получается заменой $K_i=K_p/T_i$, $K_d=K_p/T_d$ и выглядит следующим образом:
$$
u(t)=K_p(e(t)+\frac{1}{T_i}\int_0^t e(t')dt'+T_d \frac{de(t)}{dt})
$$	
	где компоненты $T_i$, $T_d$ обозначают время интегрирования и время производной.
	
	При управлении некоторыми системами лучших результатов можно добиться использованием только двух или одной частей PID и таким образом он превращается в PI, PD, P или I регулятор. PI регуляторы довольно популярны так как дифференциальная составляющая управления сильно подвержена влиянию ошибок измерений, в то время как отсутствие интегральной составляющей может привести к тому что система никогда не достигнет её целевого состояния.
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Влияние отдельных составяющих PID регулятора}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	Пропорциональная составляющая реагирует на размер текущей ошибки: большое значение ошибки означает сильную реакцию управления. Ошибки будут уменьшаться при увеличении пропорционального коэффициента $K_p$, однако система будет более подвержена колебаниям. Также данная составляющая перестает работать для очень малых ошибок. Другим недостатком этой составляющей является то, что она не реагирует на скорость изменения ошибок. На практике коэффициент данной составляющей выбирается так чтобы она оказывала наибольшее влияние на управление среди всех составляющих PID.
	
	Интегральная составляющая предназначена для корректирования малых ошибок. Эта составляющая учитывает ошибки в течение периода времени и увеличивает важность малых ошибок с течением времени. Интегральная составляющая равна ошибкам, умноженным на время их присутствия. Таким образом интегральная составляющая увеличивает реакцию PID на ошибку с течением пока времени она не будет скорректирована. Временной промежуток интеграла также может быть настроен для конкретной системы. Например, более короткий временной промежуток приводит к более быстрому исправлению ошибок. Однако слишком короткий промежуток приведет к неустойчивой работе регулятора, а слишком длинный приведет к тому, что возникающие ошибки будут слишком долго влиять на управление системой.
	
	Дифференциальная составляющая ориентируется на скорость изменения ошибок. Она реагирует на резкие изменения системы и пытается предсказать будущее поведение системы, что улучшает время стабилизации системы и её устойчивость. Крайне важно чтобы дифференциальная часть не была слишком большой, иначе она вызовет слишком сильные колебания управление или неустойчивую работу регулятора. На практике дифференциальная часть используется редко из-за сильно влияния шума во время измерений на неё.
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Настройка PID регулятора}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	Под настройкой понимается изменение параметров регулятора для получения желаемого управления. Устойчивость (по крайней мере отсутствие неограниченных колебаний) является одним из основных требований, но конкретные системы могут иметь и другие требования к регулятору.
	
	Настройка PID является сложной задачей, не смотря на интуитивность и простоту трех его параметров. И она сильно усложняется для нелинейных систем с несколькими этапами работы, для таких систем параметры PID настраиваются отдельно для каждого этапа и потом меняются во время работы системы. Существует множество различных методов настройки PID, в данной работе приведены два наиболее известных. 
	
	Самым простым методом является ручная настройка регулятора. При ручной настройке параметры $K_i$ и $K_d$ приравнивают к нулю, после чего параметр $K_p$ увеличивают пока полученное состояние системы не начнет колебаться вокруг желаемого. Затем увеличивают параметр $K_i$ пока полученные ранее отклонения не будут корректироваться за время, подходящее для конкретного процесса. Но при излишне больших значениях $K_i$ управление станет неустойчивым т.к. интегральная составляющая будет продолжать оказывать сильное влияние на систему из-за отклонений, которые уже давно были скорректированы, и таким образом приводить к новым отклонениям. После увеличения $K_i$ увеличивают $K_d$ пока управление не начнет достаточно быстро реагировать на отклонения системы. Излишнее увеличение параметра $K_d$ приведет к слишком резким колебаниям управления даже при малых отклонениях. Данный метод требует больших временных затрат из-за необходимости подбора всех параметров вручную.
	
	Другим хорошо известным методом настройки PID регуляторов является метод Зийглера-Никольса. Как и в ранее описанном методе параметры $K_i$, $K_d$ изначально приравниваются к нулю. Параметр $K_p$ увеличивается пока он не достигнет максимального значения $K_u$ при котором управляемая система постоянно колеблется, после чего период колебаний используется для определения остальных параметров.

	Один из вариантов выбора параметров (существуют и другие в зависимости от существенности превышений управления) изложен в таблице: 
\begin{center}
\begin{tabular}{|c|c|c|c|} 
\hline
Тип регулятора & $K_p$ & $K_i$ & $K_d$ \\ 
\hline
P & 0.50$K_u$ & - & - \\ 
\hline
PI & 0.45$K_u$ & 0.54$K_u/T_u$ & - \\ 
\hline
PID & 0.60$K_u$ & 1.2$K_u/T_u$ & 3$K_uT_u/40$ \\ 
\hline
\end{tabular}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Введение в построение оптимальных траекторий для уличного движения в системе координат Френе}\label{1sec:optimal-control}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	С продвижением развития беспилотных автомобилей вперед, к разрешению реальных дорожных ситуаций, они сталкиваются со сценариями, где движения других автомобилей должно учитываться в явном виде. Это включает в себя повседневные маневры, такие как перестроения из одной линии в другую, движение вместе с другими автомобилями, избежание столкновений. Существует множество простых эвристических подходов к решению этих проблем, однако они плохо справляются с движением в плотном трафике на больших скоростях и даже могут привести к авариям на дороге. Данный метод специально разрабатывался для движения по шоссе и определяет траектории движения, не зависящие от скорости, где скорость и дистанция до других автомобилей определяется на уровне планирования. В дополнении к этому, метод подходит для быстрого избегания препятствий.
	
	Применение принципов оптимального управления для построения траекторий движения --- это не новая идея. Но в отличие от большинства других работ, данный метод не нацелен на минимизацию какой-то целевой функции. Вместо этого задача следования траектории формулируется в смысле оптимального управления для того, чтобы воспользоваться тем, что оптимальная траектория будет непрерывной все время. Используя это свойство, данный метод будет придерживаться найденного оптимального решения (применение принципа оптимальности Беллмана). Для автомобиля это будет означать, что каждая следующая траектория начинается с точек предыдущей и таким образом локальная непрерывность сохраняется. Такое построение траекторий сильно отличается от других методов, которые представляя все систему через полиномы оптимизируют некоторый функционал и на каждом шаге строят траекторию, отличающуюся от предыдущей. В результате этих малых отличий движение по дороге становится нестабильным и даже опасным.
	
	В то время как основным критерием выбора целевой функции является соблюдение принципа оптимальности Беллмана, траектории минимизирующие его должны соответствовать желаемому движению беспилотного автомобиля. Кратко описать идеальное поведение автомобиля можно следующим образом: предполагая, что автомобиль движется с некоторым поперечным отклонением от выбранной полосы, к примеру из-за того, что начался маневр перестроения. Автомобиль должен переместится к центру выбранной полосы, учитывая его физические ограничения и компромисс между комфортном пассажиров и временем на перемещение. Аналогично можно определить поведение для продольных отклонений: предполагая, что автомобиль движется слишком быстро или слишком близко к впереди идущему, нужно замедлить движение без резких скачков. С математической точки зрения комфорт пассажиров можно описать через тряску, которую будем определять как изменение ускорения с течением времени. 
	
	Решение общего случая задачи оптимального управления с ограничениями является крайне сложным и может быть в лучшем случае решено вычислительными методами. Поэтому применяется подход с поиском решений для неограниченной задачи и выбором решения, которое соответствуют ограничениям исходной задачи. Это означает, что найденные подходящие под ограничения решения будут обладать локальной непрерывностью. 
	
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Планирование движения в системе координат Френе}\label{1sec:optimal-control}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	Использование системы координат Френе является хорошо известным подходом в теории оптимального управления. В данном методе этот подход будет применен для комбинирования различных фелевых функций продольного и поперечного движения и имитации поведения человека при езде по шоссе. Подвижная система координат определяется двумя нормальными векторами $\overrightarrow{t_r}$, $\overrightarrow{n_r}$ в определенной точке некоторой кривой, являющейся центральной линией при следовании. Эта центральная линия представляет собой или идеальный путь вдоль дороги или просто центром дороги. Вместо построения траектории напрямую в картезиановых координатах, используется предложенная система координат.
	
$$
\overrightarrow{x}(s(t),d(t))=\overrightarrow{r}(s(t))+d(t)\overrightarrow{n_r}(s(t))
$$

	где $d(t)$ --- поперечное отклонение, $s(t)$ --- пройденная длинна кривой центра пути, $\overrightarrow{t_x}, \overrightarrow{n_x}$ --- нормальный и направляющий вектора полученной траеткории.

	Так как пары векторов  $\overrightarrow{t_s}$, $\overrightarrow{n_s}$ и $\overrightarrow{t_x}$, $\overrightarrow{n_x}$ почти совпадают на больших скоростях, ранее введенное понятие тряски определяется как $\dddot{d}$ и $\dddot{s}$. Из [15] ясно что многочлены пятой степени являются оптимальной связью между начальным состоянием $P_0=[p_0,\dot{p_0},\ddot{p_0}]$ и конечным $P_1=[p_1,\dot{p_1},\ddot{p_1}]$ на временном интервале в случае одномерной задачи. Точнее, они минимизируют целевой функционал определенный как интеграл квардрата тряски от времени:
	
$$
J_t(p(t)) = \int_{t_0}^{t_1}\dddot{p}^2(\tau)d\tau
$$

	Очевидно, что имея начальное состояние $P_0=[p_0,\dot{p_0},\ddot{p_0}]$ в момент $t_0$ и $[\dot{p_1},\ddot{p_1}]$ конечного состояния $P_1$ в момент $t_1=t_0+T$ решение задачи с целевой функцией $C_d=k_jJ_t+k_tg(T)+k_ph(p_1)$ с произвольными $g$, $h$ и $k_j,k_t,k_p>0$ является многочленом пятой степени.
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Планирование движения}\label{1sec:optimal-control}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	Рассмотрим планирование поперечного движения на высоких скоростях. Для планирования поперечной части движения выберем начальное состояние $D_0=[d_0,\dot{d_0},\ddot{d_0}]$ в учетом предыдущей траектории. Для конечного состояния выбирается $\dot{d_1}=\ddot{d_1}=0$. И используется следующую целевую функцию:
$$
C_d=k_jJ_t(d(t))+k_tT+k_dd_1^2
$$
	Вместо поиска одной идеальной траектории, комбинирование различных $d_i$ и $T_j$ строится целое множество траекторий:
$$
[d_1,\dot{d_1},\ddot{d_1},T]_{ij}=[d_i,0,0,T_j]
$$
	После чего из этого множества выбираются траектории подходящие под ограничения и из них выбирается траектория с наименьшей стоимостью.

	При высоких скоростях $d(t)$ и $s(t)$ могут быть выбраны независимо, в то время как в условиях низких скоростей связь между поперечным и продольным движением должна быть учтена.
	
$$
\overrightarrow{x}(s(t),d(t))=\overrightarrow{r}(s(t))+d(s(t))\overrightarrow{n_r}(s(t))
$$
	Применяя измененную целевую функцию $C_d=k_jJ_s(d(s))+k_tS+k_dd_1^2$ где $S=s_1-s_0$ и $(\cdot)'=\frac{\partial}{\partial s}(\cdot)$,
$$
J_s(d(s)) = \int_{s_0}^{s_1}(d''')^2(\sigma)d\sigma
$$
	Траектории строятся по аналогичному принципу. Пример процесса построения траекторий:
	
\includegraphics[width=\linewidth]{lateralCurves.png}
	
	Зеленым цветом выделена оптимальная траектория, черным - подходящие под ограничения траектории, серым - не подходящие под ограничения.
	
	Для построения продольного движения переход от начального состояния $S_0=[s_0,\dot{s_0},\ddot{s_0}]$ до желаемой, возможно движущейся, позиции $s_{target}(t)$ описывается аналогичным образом.

$$
[s_1,\dot{s_1},\ddot{s_1},T]_{ij}=[[s_{target}(T_j)+\Delta s_i],\dot{s_{target}}(T_j),\ddot{s_{target}}(T_j),T_j]
$$
	С использованием следующей целевой функции:
$$
C_t=k_jJ_t+k_tT+k_s[s_1-s_d]^2
$$	
	Затем для каждого конкретного сценария поведения (следования за другим автомобилем, перестроением, остановки, поддержания постоянной скорости) выбирается своя функция $s_{target}(t)$ и проводится поиск оптимальной траектории по ранее описанному принципу.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Решение задач с использованием CasADi для Python}\label{1sec:optimal-control}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	CasADI это кроссплатформенная библиотека с открытым исходным кодом обладающая API для Python, C++, Matlab/Octave и предназначенная для нелинейной оптимизации и алгоритмического дифференцирования \cite{Andersson}. Она использует быструю и эффективную реализацию различных методов для численного оптимального управления.

	Основа CasADi это символический фреймворк реализующий прямой и обратный метод алгоритмического дифференцирования на графах выражений для построения градиентов, больших и разреженных якобианов и гессианов. Эти графы выражений, представленные в виде функциональных объектов, могут быть вычислены с помощью виртуальной машины или экспортированы в C код.

	Пример использования:
\begin{lstlisting}
from casadi import *

# Создаем символический скаляр/матрицу
x = MX.sym('x',5)

# Создаем выражение
y = norm_2(x)

# Градиент выражения -> новое выражение
grad_y = gradient(y,x)

# Создаем функцию для вычисления выражения
f = Function('f',[x],[grad_y])

# Вычисляем алгебраически
grad_y_num = f([1,2,3,4,5])
\end{lstlisting}

	CasADi так же способна решать задачи для динамических систем. Задачи с начальным значением в обыкновенной или дифференциально-алгебраических уравнениях (ОДУ/ДАУ) могут быть вычислены, используя явный или неявный метод Рунге-Кутта или интерфейсы к другим методам из SUNDIALS набора. Производные вычисляются использую чувствительные выражения до произвольного порядка.

	Класс проблем:
$$
	\dot{x} = f_{ode}(t;x;z;p), x(0) = x_0
$$
$$
	0 = f_{alg}(t;x;z;p)
$$

	Пример задачи:
$$
	\dot{x_1} = (1-x_2^2)x_1 - x_2
$$
$$
	\dot{x_2} = x_1,
$$
$$
	x_1(0) = 0,
$$
$$
	x_2(0) = 1.
$$

	Пример использования:
\begin{lstlisting}
import casadi.*

x = MX.sym('x',2) # Два состояния

# Выражение для ОДУ правой части
z = 1-x[1]**2
rhs = vertcat(z*x[0]-x[1],x[0])

ode = {}           # определение ОДУ
ode['x'] = x       # состояния
ode['ode'] = rhs   # правая часть

# Конструируем функцию которая интегрирует через каждые 4 с
F = integrator('F','cvodes',ode,{'tf':4})

# Начинаем с x=[0;1]
res = F(x0=[0,1])

print(res["xf"])
\end{lstlisting}

	CasADi предоставляет различные методы для решения нелинейных задач и задач квадратичного программирования, в том числе и с целочисленными переменными.

	Класс задач:
$$
	\min_x f(x;p),
$$
$$
	x_{lb} \leq x \leq x_{ub},
$$
$$
	g_{lb} \leq g(x;p) \leq g_{ub}.
$$

	Пример задачи:
$$
	\min_{x,y,z} x^2+100z^2,
$$
$$
	z+(1-x)^2-y=0.
$$

	Пример использования:
\begin{lstlisting}
from casadi import *

# Символические выражения
x = MX.sym('x')
y = MX.sym('y')
z = MX.sym('z')
f = x**2+100*z**2
g = z+(1-x)**2-y

nlp = {}                   # Описание задачи
nlp['x']= vertcat(x,y,z)   # Переменные
nlp['f'] = f               # Целевая функция
nlp['g'] = g               # Ограничения

# Создаем обьект решающий задачу
F = nlpsol('F','ipopt',nlp)

# Решаем задачу используя предположение
F(x0=[2.5,3.0,0.75],ubg=0,lbg=0)
\end{lstlisting}		

	CasADi предоставляет обширный набор дифференциальных операций для матричных графов выражений, включая распространенные матричнозначные операции, серилизованные или параллельные вызовы функций, неявные функции, интеграторы, таблицы построенные на сплайнах и внешний код.

	Эти строительные блоки позволяют пользователю запрограммировать огромное множество задач оптимального управления.

	Пример использования, являющийся комбинацией описанных выше примеров:
\begin{lstlisting}
from casadi import *

x = MX.sym('x',2) # Два состояния
p = MX.sym('p')   # Свободный параметр

# Выражение для ОДУ правой части
z = 1-x[1]**2
rhs = vertcat(z*x[0]-x[1]+2*tanh(p),x[0])

# ОДУ объявление со свободным параметром
ode = {'x':x,'p':p,'ode':rhs}

# Конструируем функцию которая интегрирует через 1 с
F = integrator('F','cvodes',ode,{'tf':1})

# Вектор управления
u = MX.sym('u',4,1)

x = [0,1] # Начальное состояние
for k in range(4):
  # Интегрируем на 1с во времени
  # вызываем символический интегратор
  res = F(x0=x,p=u[k])
  x = res["xf"]

# Объявление задачи
nlp = {'x':u,'f':dot(u,u),'g':x}

# Решаем используя IPOPT
solver = nlpsol('solver','ipopt',nlp)
res = solver(x0=0.2,lbg=0,ubg=0)

plot(res["x"])
\end{lstlisting}
\bigskip

Были рассмотрены базовые понятия, используемые в остальных главах данной работы. В частности, для MPC методов были сформулированы основные понятия об структуре задачи, приведена мотивация для их использования. Особое внимание было уделено рассмотрению алгоритмов построения MPC-регуляторов и внутренней работе NMPC-регуляторов. Для PID методов приведены основополагающие понятия, информация о важности каждой отдельной составляющей. Присутствует информация о настройке параметров PID регуляторов.  Рассмотрена теория методов построения траекторий в системе координат Френе. Так же представлено краткое описание библиотеки CasADi, применяемой для реализации рассмотренных методов.